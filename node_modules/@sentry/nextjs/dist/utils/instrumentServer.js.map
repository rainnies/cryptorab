{"version":3,"file":"instrumentServer.js","sourceRoot":"","sources":["../../src/utils/instrumentServer.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport {\n  captureException,\n  configureScope,\n  deepReadDirSync,\n  getCurrentHub,\n  Handlers,\n  startTransaction,\n} from '@sentry/node';\nimport { extractTraceparentData, getActiveTransaction, hasTracingEnabled } from '@sentry/tracing';\nimport { addExceptionMechanism, fill, isString, logger, stripUrlQueryAndFragment } from '@sentry/utils';\nimport * as domain from 'domain';\nimport * as http from 'http';\nimport { default as createNextServer } from 'next';\nimport * as querystring from 'querystring';\nimport * as url from 'url';\n\nconst { parseRequest } = Handlers;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype PlainObject<T = any> = { [key: string]: T };\n\n// class used by `next` as a proxy to the real server; see\n// https://github.com/vercel/next.js/blob/4443d6f3d36b107e833376c2720c1e206eee720d/packages/next/server/next.ts#L32\ninterface NextServer {\n  server: Server;\n  createServer: (options: PlainObject) => Server;\n}\n\n// `next`'s main server class; see\n// https://github.com/vercel/next.js/blob/4443d6f3d36b107e833376c2720c1e206eee720d/packages/next/next-server/server/next-server.ts#L132\ninterface Server {\n  dir: string;\n  publicDir: string;\n}\n\nexport interface NextRequest extends http.IncomingMessage {\n  cookies: Record<string, string>;\n  url: string;\n  query: { [key: string]: string };\n  headers: { [key: string]: string };\n  body: string | { [key: string]: unknown };\n}\ntype NextResponse = http.ServerResponse;\n\n// the methods we'll wrap\ntype HandlerGetter = () => Promise<ReqHandler>;\ntype ReqHandler = (req: NextRequest, res: NextResponse, parsedUrl?: url.UrlWithParsedQuery) => Promise<void>;\ntype ErrorLogger = (err: Error) => void;\ntype ApiPageEnsurer = (path: string) => Promise<void>;\ntype PageComponentFinder = (\n  pathname: string,\n  query: querystring.ParsedUrlQuery,\n  params: { [key: string]: unknown } | null,\n) => Promise<{ [key: string]: unknown } | null>;\n\n// these aliases are purely to make the function signatures more easily understandable\ntype WrappedHandlerGetter = HandlerGetter;\ntype WrappedErrorLogger = ErrorLogger;\ntype WrappedReqHandler = ReqHandler;\ntype WrappedApiPageEnsurer = ApiPageEnsurer;\ntype WrappedPageComponentFinder = PageComponentFinder;\n\nlet liveServer: Server;\nlet sdkSetupComplete = false;\n\n/**\n * Do the monkeypatching and wrapping necessary to catch errors in page routes and record transactions for both page and\n * API routes.\n */\nexport function instrumentServer(): void {\n  // The full implementation here involves a lot of indirection and multiple layers of callbacks and wrapping, and is\n  // therefore potentially a little hard to follow. Here's the overall idea:\n\n  // Next.js uses two server classes, `NextServer` and `Server`, with the former proxying calls to the latter, which\n  // then does the all real work. The only access we have to either is through Next's default export,\n  // `createNextServer()`, which returns a `NextServer` instance.\n\n  // At server startup:\n  //    `next.config.js` imports SDK ->\n  //    SDK's `index.ts` runs ->\n  //    `instrumentServer()` (the function we're in right now) ->\n  //    `createNextServer()` ->\n  //    `NextServer` instance ->\n  //    `NextServer` prototype ->\n  //    Wrap `NextServer.getServerRequestHandler()`, purely to get us to the next step\n\n  // At time of first request:\n  //    Wrapped `getServerRequestHandler` runs for the first time ->\n  //    Live `NextServer` instance(via`this`) ->\n  //    Live `Server` instance (via `NextServer.server`) ->\n  //    `Server` prototype ->\n  //    Wrap `Server.logError`, `Server.handleRequest`, `Server.ensureApiPage`, and `Server.findPageComponents` methods,\n  //    then fulfill original purpose of function by passing wrapped version of `handleRequest` to caller\n\n  // Whenever caller of `NextServer.getServerRequestHandler` calls the wrapped `Server.handleRequest`:\n  //    Trace request\n\n  // Whenever something calls the wrapped `Server.logError`:\n  //    Capture error\n\n  // Whenever an API request is handled and the wrapped `Server.ensureApiPage` is called, or whenever a page request is\n  // handled and the wrapped `Server.findPageComponents` is called:\n  //    Replace URL in transaction name with parameterized version\n\n  const nextServerPrototype = Object.getPrototypeOf(createNextServer({}));\n  fill(nextServerPrototype, 'getServerRequestHandler', makeWrappedHandlerGetter);\n}\n\n/**\n * Create a wrapped version of Nextjs's `NextServer.getServerRequestHandler` method, as a way to access the running\n * `Server` instance and monkeypatch its prototype.\n *\n * @param origHandlerGetter Nextjs's `NextServer.getServerRequestHandler` method\n * @returns A wrapped version of the same method, to monkeypatch in at server startup\n */\nfunction makeWrappedHandlerGetter(origHandlerGetter: HandlerGetter): WrappedHandlerGetter {\n  // We wrap this purely in order to be able to grab data and do further monkeypatching the first time it runs.\n  // Otherwise, it's just a pass-through to the original method.\n  const wrappedHandlerGetter = async function(this: NextServer): Promise<ReqHandler> {\n    if (!sdkSetupComplete) {\n      // stash this in the closure so that `makeWrappedReqHandler` can use it\n      liveServer = this.server;\n      const serverPrototype = Object.getPrototypeOf(liveServer);\n\n      // Wrap for error capturing (`logError` gets called by `next` for all server-side errors)\n      fill(serverPrototype, 'logError', makeWrappedErrorLogger);\n\n      // Wrap for request transaction creation (`handleRequest` is called for all incoming requests, and dispatches them\n      // to the appropriate handlers)\n      fill(serverPrototype, 'handleRequest', makeWrappedReqHandler);\n\n      // Wrap as a way to grab the parameterized request URL to use as the transaction name for API requests and page\n      // requests, respectively. These methods are chosen because they're the first spot in the request-handling process\n      // where the parameterized path is provided as an argument, so it's easy to grab.\n      fill(serverPrototype, 'ensureApiPage', makeWrappedMethodForGettingParameterizedPath);\n      fill(serverPrototype, 'findPageComponents', makeWrappedMethodForGettingParameterizedPath);\n\n      sdkSetupComplete = true;\n    }\n\n    return origHandlerGetter.call(this);\n  };\n\n  return wrappedHandlerGetter;\n}\n\n/**\n * Wrap the error logger used by the server to capture exceptions which arise from functions like `getServerSideProps`.\n *\n * @param origErrorLogger The original logger from the `Server` class\n * @returns A wrapped version of that logger\n */\nfunction makeWrappedErrorLogger(origErrorLogger: ErrorLogger): WrappedErrorLogger {\n  return function(this: Server, err: Error): void {\n    // TODO add more context data here\n\n    // We can use `configureScope` rather than `withScope` here because we're using domains to ensure that each request\n    // gets its own scope. (`configureScope` has the advantage of not creating a clone of the current scope before\n    // modifying it, which in this case is unnecessary.)\n    configureScope(scope => {\n      scope.addEventProcessor(event => {\n        addExceptionMechanism(event, {\n          type: 'instrument',\n          handled: true,\n          data: {\n            function: 'logError',\n          },\n        });\n        return event;\n      });\n    });\n\n    captureException(err);\n\n    return origErrorLogger.call(this, err);\n  };\n}\n\n// inspired by next's public file routing; see\n// https://github.com/vercel/next.js/blob/4443d6f3d36b107e833376c2720c1e206eee720d/packages/next/next-server/server/next-server.ts#L1166\nfunction getPublicDirFiles(): Set<string> {\n  try {\n    // we need the paths here to match the format of a request url, which means they must:\n    // - start with a slash\n    // - use forward slashes rather than backslashes\n    // - be URL-encoded\n    const dirContents = deepReadDirSync(liveServer.publicDir).map(filepath =>\n      encodeURI(`/${filepath.replace(/\\\\/g, '/')}`),\n    );\n    return new Set(dirContents);\n  } catch (_) {\n    return new Set();\n  }\n}\n\n/**\n * Wrap the server's request handler to be able to create request transactions.\n *\n * @param origReqHandler The original request handler from the `Server` class\n * @returns A wrapped version of that handler\n */\nfunction makeWrappedReqHandler(origReqHandler: ReqHandler): WrappedReqHandler {\n  const publicDirFiles = getPublicDirFiles();\n  // add transaction start and stop to the normal request handling\n  const wrappedReqHandler = async function(\n    this: Server,\n    req: NextRequest,\n    res: NextResponse,\n    parsedUrl?: url.UrlWithParsedQuery,\n  ): Promise<void> {\n    // wrap everything in a domain in order to prevent scope bleed between requests\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n    // TODO could this replace wrapping the error logger?\n    // local.on('error', Sentry.captureException);\n\n    local.run(() => {\n      const currentScope = getCurrentHub().getScope();\n\n      if (currentScope) {\n        currentScope.addEventProcessor(event => parseRequest(event, req));\n\n        // We only want to record page and API requests\n        if (hasTracingEnabled() && shouldTraceRequest(req.url, publicDirFiles)) {\n          // If there is a trace header set, extract the data from it (parentSpanId, traceId, and sampling decision)\n          let traceparentData;\n          if (req.headers && isString(req.headers['sentry-trace'])) {\n            traceparentData = extractTraceparentData(req.headers['sentry-trace'] as string);\n            logger.log(`[Tracing] Continuing trace ${traceparentData?.traceId}.`);\n          }\n\n          // pull off query string, if any\n          const reqPath = stripUrlQueryAndFragment(req.url);\n\n          // requests for pages will only ever be GET requests, so don't bother to include the method in the transaction\n          // name; requests to API routes could be GET, POST, PUT, etc, so do include it there\n          const namePrefix = req.url.startsWith('/api') ? `${(req.method || 'GET').toUpperCase()} ` : '';\n\n          const transaction = startTransaction(\n            {\n              name: `${namePrefix}${reqPath}`,\n              op: 'http.server',\n              metadata: { requestPath: reqPath },\n              ...traceparentData,\n            },\n            // extra context passed to the `tracesSampler`\n            { request: req },\n          );\n\n          currentScope.setSpan(transaction);\n\n          res.once('finish', () => {\n            const transaction = getActiveTransaction();\n            if (transaction) {\n              transaction.setHttpStatus(res.statusCode);\n\n              // we'll collect this data in a more targeted way in the event processor we added above,\n              // `addRequestDataToEvent`\n              delete transaction.metadata.requestPath;\n\n              // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the\n              // transaction closes\n              setImmediate(() => {\n                transaction.finish();\n              });\n            }\n          });\n        }\n      }\n\n      return origReqHandler.call(this, req, res, parsedUrl);\n    });\n  };\n\n  return wrappedReqHandler;\n}\n\n/**\n * Wrap the given method in order to use the parameterized path passed to it in the transaction name.\n *\n * @param origMethod Either `ensureApiPage` (called for every API request) or `findPageComponents` (called for every\n * page request), both from the `Server` class\n * @returns A wrapped version of the given method\n */\nfunction makeWrappedMethodForGettingParameterizedPath(\n  origMethod: ApiPageEnsurer | PageComponentFinder,\n): WrappedApiPageEnsurer | WrappedPageComponentFinder {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const wrappedMethod = async function(this: Server, parameterizedPath: string, ...args: any[]): Promise<any> {\n    const transaction = getActiveTransaction();\n\n    // replace specific URL with parameterized version\n    if (transaction && transaction.metadata.requestPath) {\n      const origPath = transaction.metadata.requestPath;\n      transaction.name = transaction.name.replace(origPath, parameterizedPath);\n    }\n\n    return origMethod.call(this, parameterizedPath, ...args);\n  };\n\n  return wrappedMethod;\n}\n\n/**\n * Determine if the request should be traced, by filtering out requests for internal next files and static resources.\n *\n * @param url The URL of the request\n * @param publicDirFiles A set containing relative paths to all available static resources (note that this does not\n * include static *pages*, but rather images and the like)\n * @returns false if the URL is for an internal or static resource\n */\nfunction shouldTraceRequest(url: string, publicDirFiles: Set<string>): boolean {\n  // `static` is a deprecated but still-functional location for static resources\n  return !url.startsWith('/_next/') && !url.startsWith('/static/') && !publicDirFiles.has(url);\n}\n"]}