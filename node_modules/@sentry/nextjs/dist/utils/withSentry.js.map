{"version":3,"file":"withSentry.js","sourceRoot":"","sources":["../../src/utils/withSentry.ts"],"names":[],"mappings":"AAAA,iBA4OA;;;AA5OA,qCAAkG;AAClG,2CAA4E;AAE5E,uCAA6G;AAC7G,+BAAiC;AAGzB,IAAA,2CAAY,CAAc;AAUlC,6EAA6E;AAChE,QAAA,UAAU,GAAG,UAAC,WAA2B;IACpD,6EAA6E;IAC7E,OAAO,UAAO,GAAG,EAAE,GAAG;;;;YACpB,kHAAkH;YAClH,yGAAyG;YACzG,6DAA6D;YAC7D,GAAG,CAAC,GAAG,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAG3B,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC;YAC9B,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACf,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAKT,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC;;;;;;;4BACxB,YAAY,GAAG,oBAAa,EAAE,CAAC,QAAQ,EAAE,CAAC;4BAEhD,IAAI,YAAY,EAAE;gCAChB,YAAY,CAAC,iBAAiB,CAAC,UAAA,KAAK,IAAI,OAAA,YAAY,CAAC,KAAK,EAAE,GAAG,CAAC,EAAxB,CAAwB,CAAC,CAAC;gCAElE,IAAI,2BAAiB,EAAE,EAAE;oCAEnB,eAAe,SAAA,CAAC;oCACpB,IAAI,GAAG,CAAC,OAAO,IAAI,gBAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,EAAE;wCACxD,eAAe,GAAG,gCAAsB,CAAC,GAAG,CAAC,OAAO,CAAC,cAAc,CAAW,CAAC,CAAC;wCAChF,cAAM,CAAC,GAAG,CAAC,uCAA8B,eAAe,0CAAE,OAAO,OAAG,CAAC,CAAC;qCACvE;oCAEK,GAAG,GAAG,KAAG,GAAG,CAAC,GAAK,CAAC;oCAErB,OAAO,GAAG,gCAAwB,CAAC,GAAG,CAAC,CAAC;oCAC5C,2BAA2B;oCAC3B,IAAI,GAAG,CAAC,KAAK,EAAE;;4CACb,wGAAwG;4CACxG,2BAA2B;4CAC3B,KAA2B,KAAA,iBAAA,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA,4CAAE;gDAA3C,KAAA,2BAAY,EAAX,GAAG,QAAA,EAAE,KAAK,QAAA;gDACpB,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAG,KAAO,EAAE,MAAI,GAAG,MAAG,CAAC,CAAC;6CACnD;;;;;;;;;qCACF;oCACK,SAAS,GAAM,CAAC,GAAG,CAAC,MAAM,IAAI,KAAK,CAAC,CAAC,WAAW,EAAE,MAAG,CAAC;oCAEtD,WAAW,GAAG,uBAAgB,oBAEhC,IAAI,EAAE,KAAG,SAAS,GAAG,OAAS,EAC9B,EAAE,EAAE,aAAa,IACd,eAAe;oCAEpB,8CAA8C;oCAC9C,EAAE,OAAO,EAAE,GAAG,EAAE,CACjB,CAAC;oCACF,YAAY,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;oCAElC,0GAA0G;oCAC1G,gFAAgF;oCAC/E,GAAgC,CAAC,mBAAmB,GAAG,WAAW,CAAC;iCACrE;6BACF;;;;4BAGuB,qBAAM,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,EAAA;;4BAA3C,aAAa,GAAG,SAA2B;4BAEjD,4GAA4G;4BAC5G,+GAA+G;4BAC/G,0CAA0C;4BAC1C,EAAE;4BACF,2GAA2G;4BAC3G,yGAAyG;4BACzG,8GAA8G;4BAC9G,sFAAsF;4BACtF,EAAE;4BACF,6GAA6G;4BAC7G,2GAA2G;4BAC3G,+GAA+G;4BAC/G,2GAA2G;4BAC3G,gHAAgH;4BAChH,wCAAwC;4BACxC,EAAE;4BACF,0GAA0G;4BAC1G,4GAA4G;4BAC5G,4GAA4G;4BAC5G,+CAA+C;4BAC/C,EAAE;4BACF,4GAA4G;4BAC5G,6DAA6D;4BAC7D,EAAE;4BACF,yGAAyG;4BACzG,8GAA8G;4BAC9G,+GAA+G;4BAC/G,uGAAuG;4BACvG,qGAAqG;4BACrG,+GAA+G;4BAC/G,uCAAuC;4BACvC,EAAE;4BACF,8GAA8G;4BAC9G,2GAA2G;4BAC3G,EAAE;4BACF,0GAA0G;4BAC1G,8GAA8G;4BAC9G,6GAA6G;4BAC7G,8GAA8G;4BAC9G,8GAA8G;4BAC9G,kGAAkG;4BAClG,EAAE;4BACF,MAAM;4BACN,8HAA8H;4BAC9H,MAAM;4BACN,gHAAgH;4BAChH,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC;4BAEpB,sBAAO,aAAa,EAAC;;;4BAMf,cAAc,GAAG,iBAAS,CAAC,GAAC,CAAC,CAAC;4BAEpC,IAAI,YAAY,EAAE;gCAChB,YAAY,CAAC,iBAAiB,CAAC,UAAA,KAAK;oCAClC,6BAAqB,CAAC,KAAK,EAAE;wCAC3B,IAAI,EAAE,YAAY;wCAClB,OAAO,EAAE,IAAI;wCACb,IAAI,EAAE;4CACJ,eAAe,EAAE,WAAW,CAAC,IAAI;4CACjC,QAAQ,EAAE,YAAY;yCACvB;qCACF,CAAC,CAAC;oCACH,OAAO,KAAK,CAAC;gCACf,CAAC,CAAC,CAAC;gCAEH,uBAAgB,CAAC,cAAc,CAAC,CAAC;6BAClC;4BAED,4GAA4G;4BAC5G,8GAA8G;4BAC9G,iCAAiC;4BACjC,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC;4BACrB,GAAG,CAAC,aAAa,GAAG,uBAAuB,CAAC;4BAE5C,4GAA4G;4BAC5G,gHAAgH;4BAChH,wGAAwG;4BACxG,wGAAwG;4BACxG,qBAAM,sBAAsB,CAAC,GAAG,CAAC,EAAA;;4BAJjC,4GAA4G;4BAC5G,gHAAgH;4BAChH,wGAAwG;4BACxG,wGAAwG;4BACxG,SAAiC,CAAC;4BAElC,8GAA8G;4BAC9G,gHAAgH;4BAChH,8CAA8C;4BAC9C,MAAM,cAAc,CAAC;;;;iBAExB,CAAC,CAAC;YAEH,oHAAoH;YACpH,8FAA8F;YAC9F,sBAAO,YAAY,EAAE,EAAC;;SACvB,CAAC;AACJ,CAAC,CAAC;AAKF;;;;;;;;;GASG;AACH,SAAS,aAAa,CAAC,OAA0B;IAC/C,OAAO,SAAe,MAAM;QAAiC,cAAkB;aAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;YAAlB,yBAAkB;;;;;4BAC7E,qBAAM,sBAAsB,CAAC,IAAI,CAAC,EAAA;;wBAAlC,SAAkC,CAAC;wBAEnC,+GAA+G;wBAC/G,8GAA8G;wBAC9G,oHAAoH;wBACpH,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;wBAEtB,sBAAO,OAAO,CAAC,IAAI,OAAZ,OAAO,oBAAM,IAAI,GAAK,IAAI,IAAE;;;;KACpC,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,SAAe,sBAAsB,CAAC,GAA6B;;;;;;oBACpC,WAAW,GAAK,GAAG,oBAAR,CAAS;yBAE7C,WAAW,EAAX,wBAAW;oBACb,WAAW,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAIpC,mBAAmB,GAAkB,IAAI,OAAO,CAAC,UAAA,OAAO;wBAC5D,YAAY,CAAC;4BACX,WAAW,CAAC,MAAM,EAAE,CAAC;4BACrB,OAAO,EAAE,CAAC;wBACZ,CAAC,CAAC,CAAC;oBACL,CAAC,CAAC,CAAC;oBACH,qBAAM,mBAAmB,EAAA;;oBAAzB,SAAyB,CAAC;;;;oBAM1B,cAAM,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC;oBACjC,qBAAM,YAAK,CAAC,IAAI,CAAC,EAAA;;oBAAjB,SAAiB,CAAC;oBAClB,cAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;;;;oBAEnC,cAAM,CAAC,GAAG,CAAC,mCAAiC,GAAG,CAAC,CAAC;;;;;;CAEpD","sourcesContent":["import { captureException, flush, getCurrentHub, Handlers, startTransaction } from '@sentry/node';\nimport { extractTraceparentData, hasTracingEnabled } from '@sentry/tracing';\nimport { Transaction } from '@sentry/types';\nimport { addExceptionMechanism, isString, logger, objectify, stripUrlQueryAndFragment } from '@sentry/utils';\nimport * as domain from 'domain';\nimport { NextApiHandler, NextApiRequest, NextApiResponse } from 'next';\n\nconst { parseRequest } = Handlers;\n\n// This is the same as the `NextApiHandler` type, except instead of having a return type of `void | Promise<void>`, it's\n// only `Promise<void>`, because wrapped handlers are always async\nexport type WrappedNextApiHandler = (req: NextApiRequest, res: NextApiResponse) => Promise<void>;\n\nexport type AugmentedNextApiResponse = NextApiResponse & {\n  __sentryTransaction?: Transaction;\n};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const withSentry = (origHandler: NextApiHandler): WrappedNextApiHandler => {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  return async (req, res) => {\n    // first order of business: monkeypatch `res.end()` so that it will wait for us to send events to sentry before it\n    // fires (if we don't do this, the lambda will close too early and events will be either delayed or lost)\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    res.end = wrapEndMethod(res.end);\n\n    // use a domain in order to prevent scope bleed between requests\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n\n    // `local.bind` causes everything to run inside a domain, just like `local.run` does, but it also lets the callback\n    // return a value. In our case, all any of the codepaths return is a promise of `void`, but nextjs still counts on\n    // getting that before it will finish the response.\n    const boundHandler = local.bind(async () => {\n      const currentScope = getCurrentHub().getScope();\n\n      if (currentScope) {\n        currentScope.addEventProcessor(event => parseRequest(event, req));\n\n        if (hasTracingEnabled()) {\n          // If there is a trace header set, extract the data from it (parentSpanId, traceId, and sampling decision)\n          let traceparentData;\n          if (req.headers && isString(req.headers['sentry-trace'])) {\n            traceparentData = extractTraceparentData(req.headers['sentry-trace'] as string);\n            logger.log(`[Tracing] Continuing trace ${traceparentData?.traceId}.`);\n          }\n\n          const url = `${req.url}`;\n          // pull off query string, if any\n          let reqPath = stripUrlQueryAndFragment(url);\n          // Replace with placeholder\n          if (req.query) {\n            // TODO get this from next if possible, to avoid accidentally replacing non-dynamic parts of the path if\n            // they match dynamic parts\n            for (const [key, value] of Object.entries(req.query)) {\n              reqPath = reqPath.replace(`${value}`, `[${key}]`);\n            }\n          }\n          const reqMethod = `${(req.method || 'GET').toUpperCase()} `;\n\n          const transaction = startTransaction(\n            {\n              name: `${reqMethod}${reqPath}`,\n              op: 'http.server',\n              ...traceparentData,\n            },\n            // extra context passed to the `tracesSampler`\n            { request: req },\n          );\n          currentScope.setSpan(transaction);\n\n          // save a link to the transaction on the response, so that even if there's an error (landing us outside of\n          // the domain), we can still finish it (albeit possibly missing some scope data)\n          (res as AugmentedNextApiResponse).__sentryTransaction = transaction;\n        }\n      }\n\n      try {\n        const handlerResult = await origHandler(req, res);\n\n        // Temporarily mark the response as finished, as a hack to get nextjs to not complain that we're coming back\n        // from the handler successfully without `res.end()` having completed its work.  This is necessary (and we know\n        // we can do it safely) for a few reasons:\n        //\n        // - Normally, `res.end()` is sync and completes before the request handler returns, as part of the handler\n        //   sending data back to the client. As soon as the handler is done, nextjs checks to make sure that the\n        //   response is indeed finished. (`res.end()` signals this by setting `res.finished` to `true`.) If it isn't,\n        //   nextjs complains. (\"Warning: API resolved without sending a response for <url>.\")\n        //\n        // - In order to prevent the lambda running the route handler from shutting down before we can send events to\n        //   Sentry, we monkeypatch `res.end()` so that we can call `flush()`, wait for it to finish, and only then\n        //   allow the response to be marked complete. This turns the normally-sync `res.end()` into an async function,\n        //   which isn't awaited because it's assumed to still be sync. As a result, nextjs runs the aforementioned\n        //   check before the now-async `res.end()` has had a chance to set `res.finished = false`, and therefore thinks\n        //   there's a problem when there's not.\n        //\n        // - In order to trick nextjs into not complaining, we can set `res.finished` to `true` before exiting the\n        //   handler. If we do that, though, `res.end()` gets mad because it thinks *it* should be the one to get to\n        //   mark the response complete. We therefore need to flip it back to `false` 1) after nextjs's check but 2)\n        //   before the original `res.end()` is called.\n        //\n        // - The second part is easy - we control when the original `res.end()` is called, so we can do the flipping\n        //   right beforehand and `res.end()` will be none the wiser.\n        //\n        // - The first part isn't as obvious. How do we know we won't end up with a race condition, such that the\n        //   flipping to `false` might happen before the check, negating the entire purpose of this hack? Fortunately,\n        //   before it's done, our async `res.end()` wrapper has to await a `setImmediate()` callback, guaranteeing its\n        //   run lasts at least until the next event loop. The check, on the other hand, happens synchronously,\n        //   immediately after the request handler (so in the same event loop). So as long as we wait to flip\n        //   `res.finished` back to `false` until after the `setImmediate` callback has run, we know we'll be safely in\n        //   the next event loop when we do so.\n        //\n        // And with that, everybody's happy: Nextjs doesn't complain about an unfinished response, `res.end()` doesnâ€™t\n        // complain about an already-finished response, and we have time to make sure events are flushed to Sentry.\n        //\n        // One final note: It might seem like making `res.end()` an awaited async function would run the danger of\n        // having the lambda close before it's done its thing, meaning we *still* might not get events sent to Sentry.\n        // Fortunately, even though it's called `res.end()`, and even though it's normally sync, a) it's far from the\n        // end of the request process, so there's other stuff which needs to happen before the lambda can close in any\n        // case, and b) that other stuff isn't triggered until `res.end()` emits a `prefinished` event, so even though\n        // it's not technically awaited, it's still the case that the process can't go on until it's done.\n        //\n        // See\n        // https://github.com/vercel/next.js/blob/e1464ae5a5061ae83ad015018d4afe41f91978b6/packages/next/server/api-utils.ts#L106-L118\n        // and\n        // https://github.com/nodejs/node/blob/d8f1823d5fca5e3c00b19530fb15343fdd3c8bf5/lib/_http_outgoing.js#L833-L911.\n        res.finished = true;\n\n        return handlerResult;\n      } catch (e) {\n        // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can\n        // store a seen flag on it. (Because of the one-way-on-Vercel-one-way-off-of-Vercel approach we've been forced\n        // to take, it can happen that the same thrown object gets caught in two different ways, and flagging it is a\n        // way to prevent it from actually being reported twice.)\n        const objectifiedErr = objectify(e);\n\n        if (currentScope) {\n          currentScope.addEventProcessor(event => {\n            addExceptionMechanism(event, {\n              type: 'instrument',\n              handled: true,\n              data: {\n                wrapped_handler: origHandler.name,\n                function: 'withSentry',\n              },\n            });\n            return event;\n          });\n\n          captureException(objectifiedErr);\n        }\n\n        // Because we're going to finish and send the transaction before passing the error onto nextjs, it won't yet\n        // have had a chance to set the status to 500, so unless we do it ourselves now, we'll incorrectly report that\n        // the transaction was error-free\n        res.statusCode = 500;\n        res.statusMessage = 'Internal Server Error';\n\n        // Make sure we have a chance to finish the transaction and flush events to Sentry before the handler errors\n        // out. (Apps which are deployed on Vercel run their API routes in lambdas, and those lambdas will shut down the\n        // moment they detect an error, so it's important to get this done before rethrowing the error. Apps not\n        // deployed serverlessly will run into this cleanup function again in `res.end(), but it'll just no-op.)\n        await finishSentryProcessing(res);\n\n        // We rethrow here so that nextjs can do with the error whatever it would normally do. (Sometimes \"whatever it\n        // would normally do\" is to allow the error to bubble up to the global handlers - another reason we need to mark\n        // the error as already having been captured.)\n        throw objectifiedErr;\n      }\n    });\n\n    // Since API route handlers are all async, nextjs always awaits the return value (meaning it's fine for us to return\n    // a promise here rather than a real result, and it saves us the overhead of an `await` call.)\n    return boundHandler();\n  };\n};\n\ntype ResponseEndMethod = AugmentedNextApiResponse['end'];\ntype WrappedResponseEndMethod = AugmentedNextApiResponse['end'];\n\n/**\n * Wrap `res.end()` so that it closes the transaction and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe', as explained in detail in the long comment in the main\n * `withSentry()` function.\n *\n * @param origEnd The original `res.end()` method\n * @returns The wrapped version\n */\nfunction wrapEndMethod(origEnd: ResponseEndMethod): WrappedResponseEndMethod {\n  return async function newEnd(this: AugmentedNextApiResponse, ...args: unknown[]) {\n    await finishSentryProcessing(this);\n\n    // If the request didn't error, we will have temporarily marked the response finished to avoid a nextjs warning\n    // message. (See long note above.) Now we need to flip `finished` back to `false` so that the real `res.end()`\n    // method doesn't throw `ERR_STREAM_WRITE_AFTER_END` (which it will if presented with an already-finished response).\n    this.finished = false;\n\n    return origEnd.call(this, ...args);\n  };\n}\n\n/**\n * Close the open transaction (if any) and flush events to Sentry.\n *\n * @param res The outgoing response for this request, on which the transaction is stored\n */\nasync function finishSentryProcessing(res: AugmentedNextApiResponse): Promise<void> {\n  const { __sentryTransaction: transaction } = res;\n\n  if (transaction) {\n    transaction.setHttpStatus(res.statusCode);\n\n    // Push `transaction.finish` to the next event loop so open spans have a better chance of finishing before the\n    // transaction closes, and make sure to wait until that's done before flushing events\n    const transactionFinished: Promise<void> = new Promise(resolve => {\n      setImmediate(() => {\n        transaction.finish();\n        resolve();\n      });\n    });\n    await transactionFinished;\n  }\n\n  // Flush the event queue to ensure that events get sent to Sentry before the response is finished and the lambda\n  // ends. If there was an error, rethrow it so that the normal exception-handling mechanisms can apply.\n  try {\n    logger.log('Flushing events...');\n    await flush(2000);\n    logger.log('Done flushing events');\n  } catch (e) {\n    logger.log(`Error while flushing events:\\n${e}`);\n  }\n}\n"]}